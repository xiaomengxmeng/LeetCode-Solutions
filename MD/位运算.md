# 位运算与逻辑运算详解

## 1. 基本概念

### 1.1 位运算

位运算是直接对整数的二进制位进行操作的运算方式，它比普通的算术运算更高效，常用于底层编程、算法优化和数据压缩等领域。

### 1.2 逻辑运算

逻辑运算是对布尔值（true/false）进行操作的运算方式，常用于条件判断和控制流程。

## 2. 位运算符详解

### 2.1 按位与（&）

- **符号**：`&`
- **运算规则**：当两个对应位都为1时，结果为1，否则为0
- **示例**：`5 & 3 = 1`（二进制：`0101 & 0011 = 0001`）
- **常用场景**：
  - 提取特定位（如 `x & 1` 获取最低位）
  - 清零特定位（如 `x & 0xFFFFFFFE` 清零最低位）

### 2.2 按位或（|）

- **符号**：`|`
- **运算规则**：当两个对应位至少有一个为1时，结果为1，否则为0
- **示例**：`5 | 3 = 7`（二进制：`0101 | 0011 = 0111`）
- **常用场景**：
  - 设置特定位（如 `x | 1` 设置最低位为1）
  - 合并两个位图

### 2.3 按位异或（^）

- **符号**：`^`
- **运算规则**：当两个对应位不同时，结果为1，否则为0
- **示例**：`5 ^ 3 = 6`（二进制：`0101 ^ 0011 = 0110`）
- **特性**：
  - `a ^ a = 0`
  - `a ^ 0 = a`
  - `a ^ b ^ c = a ^ (b ^ c)`（结合律）
- **常用场景**：
  - 交换两个变量（不使用临时变量）
  - 检测位是否不同（如汉明距离）
  - 加密和解密

### 2.4 按位取反（~）

#### 🎯 基本概念
- **符号**：`~`（波浪号）
- **运算规则**：将操作数的**每一个二进制位**都取反（0变1，1变0）
- **操作对象**：整数类型（char、short、int、long等）
- **运算级别**：单目运算符，优先级较高

#### 💡 补码表示法（关键理解）

在计算机中，整数是以**补码（Two's Complement）**形式存储的，这是理解按位取反结果的关键！

- **正数的补码**：与原码相同
- **负数的补码**：原码的符号位不变，其余位取反，然后加1

#### 📊 计算过程详解（以int类型为例）

int类型通常是32位，我们以`~5`为例，一步步计算：

1. **步骤1：写出5的二进制原码**
   ```
   5的原码：00000000 00000000 00000000 00000101
   ```
   （最高位0表示正数）

2. **步骤2：对每一位进行取反**
   ```
   取反后：11111111 11111111 11111111 11111010
   ```

3. **步骤3：解释取反后的补码**
   由于最高位是1，这是一个负数的补码。要得到它的十进制值：
   - 先对补码取反（符号位不变）：`10000000 00000000 00000000 00000101`
   - 再加1：`10000000 00000000 00000000 00000110`
   - 这是-6的原码

4. **最终结果**：`~5 = -6`

#### 📏 数据类型的影响

按位取反的结果与数据类型的位数密切相关：

| 数据类型 | 位数 | `~5`的二进制表示 | `~5`的十进制值 |
|---------|------|----------------|----------------|
| char    | 8位  | `11111010`     | -6             |
| short   | 16位 | `11111111 11111010` | -6         |
| int     | 32位 | `11111111 11111111 11111111 11111010` | -6 |
| long    | 64位 | 全1后面跟1010   | -6             |

**注意**：虽然二进制表示长度不同，但`~5`的十进制值始终是`-6`，因为补码机制保证了一致性。

#### 🎨 实际应用场景

1. **快速求相反数减1**
   ```cpp
   int x = 5;
   int result = ~x;  // result = -6 = -(x + 1)
   ```

2. **生成掩码**
   ```cpp
   // 生成一个低8位全0，其余位全1的掩码
   int mask = ~0xFF;  // 0xFFFFFF00
   ```

3. **位操作优化**
   ```cpp
   // 计算x的相反数（x != 0）
   int neg = ~x + 1;
   ```

4. **判断奇偶性的另一种方式**
   ```cpp
   // 奇数的取反是偶数，偶数的取反是奇数
   bool isOdd = (x & 1) == (~x & 1);  // 总是false，因为x和~x的最低位一定不同
   ```

#### ⚠️ 常见误区

1. **误以为是简单的"取反"**
   ```cpp
   // ❌ 错误理解：~5 = -(5+1)，但这只是结果的巧合
   // ✅ 正确理解：按位取反遵循补码规则
   ```

2. **忽略符号位**
   ```cpp
   int x = -1;  // 补码全1
   int result = ~x;  // 补码全0 → 结果是0
   ```

3. **数据类型转换问题**
   ```cpp
   unsigned char x = 5;  // 00000101
   unsigned char result = ~x;  // 11111010 → 十进制250
   ```

#### 📝 记忆口诀

**按位取反，符号改变，数值减一**
- 正数取反：`~x = -(x + 1)`
- 负数取反：`~(-x) = x - 1`

例如：
- `~5 = -6`（5是正数，结果是- (5+1)）
- `~(-5) = 4`（-5是负数，结果是5-1）

### 2.5 左移（<<）

- **符号**：`<<`
- **运算规则**：将二进制位向左移动指定的位数，右侧补0
- **示例**：`5 << 2 = 20`（二进制：`0101 << 2 = 10100`）
- **特性**：相当于乘以2的n次方（无溢出情况下）

### 2.6 右移（>>）

- **符号**：`>>`
- **运算规则**：将二进制位向右移动指定的位数
  - 对于有符号数：左侧补符号位（算术右移）
  - 对于无符号数：左侧补0（逻辑右移）
- **示例**：`5 >> 1 = 2`（二进制：`0101 >> 1 = 0010`）
- **特性**：相当于除以2的n次方（向下取整）

## 3. 逻辑运算符详解

### 3.1 逻辑与（&&）

- **符号**：`&&`
- **运算规则**：当两个操作数都为true时，结果为true，否则为false
- **短路特性**：如果第一个操作数为false，不会计算第二个操作数

### 3.2 逻辑或（||）

- **符号**：`||`
- **运算规则**：当两个操作数至少有一个为true时，结果为true，否则为false
- **短路特性**：如果第一个操作数为true，不会计算第二个操作数

### 3.3 逻辑非（!）

- **符号**：`!`
- **运算规则**：将布尔值取反（true变false，false变true）

### 3.4 逻辑异或（无直接运算符）

- **运算规则**：当两个操作数不同时，结果为true，否则为false
- **实现方式**：`(a && !b) || (!a && b)` 或 `a != b`

## 4. 位运算与逻辑运算的区别

| 特性     | 位运算             | 逻辑运算           |
| -------- | ------------------ | ------------------ |
| 操作对象 | 二进制位           | 布尔值             |
| 运算结果 | 整数               | 布尔值             |
| 短路特性 | 无                 | 有（&&和           |
| 运算符   | &,                 | , ^, ~, <<, >>     |
| 应用场景 | 底层编程、算法优化 | 条件判断、流程控制 |

## 5. 位运算的经典应用

### 🌟 为什么要学习位运算的经典应用？

位运算虽然看起来比较底层，但在实际编程中非常有用！它可以帮助我们：

- ✅ 写出更高效的代码（位运算比普通运算快很多）
- ✅ 解决一些特定的算法问题（如汉明距离、只出现一次的数字等）
- ✅ 理解计算机底层的工作原理

为了让新手朋友也能轻松理解，我们将每个经典应用都按照以下结构详细讲解：
**问题描述** → **算法思路** → **步骤分解** → **具体例子** → **代码实现**

### 🧩 5.1 汉明距离计算

**问题描述**：计算两个整数的二进制表示中，对应位不同的位置数目。例如，5（0101）和3（0011）的汉明距离是2（第2位和第3位不同）。

**算法思路**：逐位比较两个数的每一位，统计不同位的数量。这里可以利用异或运算的特性：当两位不同时，异或结果为1。

**步骤分解**：

1. 初始化计数器 `res` 为0（用于统计不同位的数量）
2. 循环处理每一位，直到两个数都变为0
3. 使用 `x & 1` 和 `y & 1` 获取两个数的最低位
4. 使用 `^` 运算比较两位是否不同（1表示不同，0表示相同）
5. 将不同位的数量累加到 `res` 中
6. 两个数都右移一位（`>>= 1`），处理下一位

**具体例子**：计算5（0101）和3（0011）的汉明距离

```
初始：x=5(0101), y=3(0011), res=0

第1次循环：
  x&1=1, y&1=1 → 1^1=0 → res=0
  x >>=1 → 2(0010), y >>=1 → 1(0001)

第2次循环：
  x&1=0, y&1=1 → 0^1=1 → res=1
  x >>=1 → 1(0001), y >>=1 → 0(0000)

第3次循环：
  x&1=1, y&1=0 → 1^0=1 → res=2
  x >>=1 → 0(0000), y >>=1 → 0(0000)

循环结束，返回res=2
```

**代码实现**：

```cpp
int hammingDistance(int x, int y) {
    int res = 0;
    while(x != 0 || y != 0) {  // 只要还有位需要处理
        res += (x & 1) ^ (y & 1);  // 比较最低位是否不同
        x >>= 1;  // x右移一位
        y >>= 1;  // y右移一位
    }
    return res;
}
```

### 🔢 5.2 判断奇偶性

**问题描述**：判断一个整数是奇数还是偶数。

**算法思路**：观察二进制数的最低位，我们可以发现一个规律：

- 偶数的二进制最低位一定是0（如6：0110）
- 奇数的二进制最低位一定是1（如7：0111）

所以，只需要判断最低位是0还是1即可。

**步骤分解**：

1. 使用 `x & 1` 获取整数的最低位
2. 如果结果为0，说明是偶数；如果结果为1，说明是奇数

**具体例子**：

- 偶数6：二进制0110 → 6&1=0 → 偶数
- 奇数7：二进制0111 → 7&1=1 → 奇数

**代码实现**：

```cpp
bool isEven(int x) {
    return (x & 1) == 0;  // 最低位是0 → 偶数
}

bool isOdd(int x) {
    return (x & 1) == 1;  // 最低位是1 → 奇数
}
```

### 🔄 5.3 交换两个变量

**问题描述**：不使用临时变量，交换两个整数的值。

**算法思路**：利用异或运算的两个重要特性：

1. `a ^ b ^ b = a`（一个数和另一个数异或两次，结果还是原数）
2. `a ^ b ^ a = b`（同理）

**步骤分解**：

1. 计算a和b的异或，结果存入a（此时a = a^b）
2. 用新的a（即a^b）和b异或，结果存入b（此时b = a^b^b = a）
3. 用新的a（即a^b）和新的b（即原来的a）异或，结果存入a（此时a = a^b^a = b）

**具体例子**：交换a=3（0011）和b=5（0101）

```
初始：a=3(0011), b=5(0101)

第1步：a = a ^ b = 0011 ^ 0101 = 0110
第2步：b = a ^ b = 0110 ^ 0101 = 0011（现在b等于原来的a）
第3步：a = a ^ b = 0110 ^ 0011 = 0101（现在a等于原来的b）

结果：a=5(0101), b=3(0011) → 交换成功！
```

**代码实现**：

```cpp
void swap(int &a, int &b) {
    a = a ^ b;  // 第1步：a = a^b
    b = a ^ b;  // 第2步：b = (a^b)^b = a
    a = a ^ b;  // 第3步：a = (a^b)^a = b
}
```

### 🗑️ 5.4 清零最低位的1

**问题描述**：将一个整数的二进制表示中，最右边的1变成0。

**算法思路**：观察x和x-1的二进制关系：

- 当x的最低位是1时（奇数），x-1会将这个1变成0
- 当x的最低位是0时（偶数），x-1会将x最右边的1变成0，并将该位右边的所有0变成1

例如：

- x=6（0110），x-1=5（0101）
- x=7（0111），x-1=6（0110）

所以，x & (x-1) 就可以清零最低位的1！

**步骤分解**：

1. 计算x-1
2. 将x和x-1进行按位与运算，结果就是清零最低位1后的数

**具体例子**：x=6（0110）

- x-1=5（0101）
- x&(x-1)=0110&0101=0100（清除了最低位的1）

**代码实现**：

```cpp
int clearLowestOne(int x) {
    return x & (x - 1);  // 清零最低位的1
}
```

### 🎯 5.5 获取最低位的1

**问题描述**：只保留整数二进制表示中最右边的1，其余位都变为0。

**算法思路**：利用补码的特性。在计算机中，负数是以补码形式存储的，-x等于x的补码，即~x+1。

例如：

- x=6（0110），-x=-6（补码：1010）
- x&(-x)=0110&1010=0010（只保留了最低位的1）

**步骤分解**：

1. 计算-x（x的补码）
2. 将x和-x进行按位与运算，结果就是只保留最低位1的数

**具体例子**：x=6（0110）

- -x= -6（二进制补码：1010）
- x&(-x)=0110&1010=0010（只保留了最低位的1）

**代码实现**：

```cpp
int getLowestOne(int x) {
    return x & -x;  // 只保留最低位的1
}
```

### 💡 5.6 判断是否为2的幂

**问题描述**：判断一个正整数是否是2的幂次方。

**算法思路**：2的幂次方的二进制表示有一个特点：只有一个1。例如：

- 2¹=2 → 0010
- 2²=4 → 0100
- 2³=8 → 1000

所以，如果一个数是2的幂，那么它的二进制表示中只有一个1，清零这个1后结果就是0。

**步骤分解**：

1. 首先判断x是否大于0（2的幂必须是正整数）
2. 计算x&(x-1)，如果结果为0，说明x是2的幂

**具体例子**：

- x=8（1000）→ x-1=7（0111）→ 8&7=0 → 是2的幂
- x=6（0110）→ x-1=5（0101）→ 6&5=0100 → 不是2的幂

**代码实现**：

```cpp
bool isPowerOfTwo(int x) {
    return x > 0 && (x & (x - 1)) == 0;  // 正整数且只有一个1
}
```

### 📏 5.7 计算绝对值

**问题描述**：计算一个整数的绝对值（不使用内置函数）。

**算法思路**：利用符号位。在计算机中，整数的最高位是符号位（0表示正数，1表示负数）。

对于32位整数：

- 正数的符号位是0，右移31位后结果是0
- 负数的符号位是1，右移31位后结果是-1（补码表示）

然后利用异或的特性：

- 正数：x ^ 0 - 0 = x → 绝对值就是本身
- 负数：x ^ (-1) - (-1) → 相当于取反加1，得到绝对值

**步骤分解**：

1. 将x右移31位，得到符号位mask（0或-1）
2. 使用x^mask对x进行处理（正数不变，负数取反）
3. 减去mask得到绝对值（正数减0，负数加1）

**具体例子**：x=-5（二进制：11111111 11111111 11111111 11111011）

- mask = -5 >> 31 = -1（二进制全1）
- x^mask = -5 ^ (-1) = 4（二进制：00000000 00000000 00000000 00000100）
- (x^mask) - mask = 4 - (-1) = 5（绝对值）

**代码实现**：

```cpp
int abs(int x) {
    int mask = x >> 31;  // 获取符号位（0或-1）
    return (x ^ mask) - mask;  // 计算绝对值
}
```

### 🎓 位运算小贴士

1. **💡 为什么位运算比普通运算快？**
   因为位运算直接在硬件层面对二进制位进行操作，不需要经过复杂的运算器处理。
2. **⚠️ 常见误区**

   - 位运算的优先级较低，注意加括号
   - 有符号数的右移是算术右移（会保留符号位）
   - 异或运算的顺序不影响结果：a^b^c = a^c^b
3. **📝 记忆小技巧**

   - `x & 1` → 取最低位
   - `x & (x-1)` → 清零最低位的1
   - `x & -x` → 获取最低位的1
   - `a ^ b ^ b` → a（异或两次同一个数，结果不变）

## 6. 位运算在算法中的应用

### 6.1 位掩码（Bitmask）

位掩码用于表示集合，每一位代表一个元素是否存在。

```cpp
// 表示集合 {0, 2, 3}
int mask = (1 << 0) | (1 << 2) | (1 << 3);  // 0b1101

// 检查元素是否存在
bool exists = mask & (1 << 2);  // true

// 添加元素
mask |= (1 << 4);  // 0b11101

// 删除元素
mask &= ~(1 << 2);  // 0b10101
```

### 6.2 状态压缩

在动态规划中，位运算常用于状态压缩，减少空间复杂度。

### 6.3 位运算优化

位运算可以优化许多算法，如：

- 快速幂算法
- 汉明重量计算
- 位图排序

## 7. 注意事项

1. **数据类型**：不同数据类型的位数不同，位运算结果可能不同
2. **符号位**：有符号数的右移是算术右移，会保留符号位
3. **溢出**：位运算可能导致溢出，需要注意
4. **可读性**：过度使用位运算可能降低代码可读性，应在性能需求明确时使用

## 8. 练习题目

1. [LeetCode 461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)
2. [LeetCode 136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)
3. [LeetCode 268. 缺失数字](https://leetcode.cn/problems/missing-number/)
4. [LeetCode 371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)

## 9. 总结

位运算和逻辑运算都是编程中重要的运算方式，它们各有特点和应用场景。位运算因其高效性在底层编程和算法优化中广泛应用，而逻辑运算则是条件判断和流程控制的基础。掌握这些运算方式，可以帮助我们编写更高效、更简洁的代码。

```

```

# 89. 格雷编码 (Gray Code)

## 问题描述
格雷编码是一个二进制数字系统，在该系统中，任意两个相邻的数都有恰好一位二进制位不同。

给定一个代表编码总位数的非负整数 n，返回所有可能的格雷编码序列。格雷编码序列必须以 0 开头。

## 代码实现

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res;
        for(int i=0; i < (1 << n); i++) {   // 第39行
            res.push_back(i ^ (i >> 1));    // 第40行
        }
        return res;
    }
};
```

## 代码详解

### 第39行：循环结构分析

```cpp
for(int i=0; i < (1 << n); i++) {
```

#### 核心解释：
- **循环变量 `i`**：从0开始，遍历所有可能的n位二进制数
- **循环条件 `i < (1 << n)`**：
  - `1 << n` 是**左移操作**，将数字1的二进制表示向左移动n位
  - 等价于数学运算 `2^n`（2的n次方）
  - 循环总共执行 `2^n` 次，恰好生成n位格雷码的总数

#### 示例说明（n=2）：
- `1 << 2 = 4`（二进制：100）
- 循环条件为 `i < 4`，即i取0,1,2,3
- 对应4个n=2位的格雷码

### 第40行：核心公式解析

```cpp
res.push_back(i ^ (i >> 1));
```

#### 核心解释：
这是生成格雷码的**关键公式**：`G(i) = i ^ (i >> 1)`

- **`i`**：当前的十进制数（从0到2^n-1）
- **`i >> 1`**：**右移操作**，将i的二进制表示向右移动1位（相当于整数除法除以2取整）
- **`^`**：**按位异或操作**，相同位为0，不同位为1

#### 公式工作原理：
1. 将原数i的二进制表示与向右移动一位的i进行异或
2. 这确保了生成的格雷码与前一个格雷码只有一位不同
3. 数学上证明了该公式满足格雷码的所有性质

#### 位运算详解：

以n=2为例，详细展示每一步的位运算过程：

| 十进制i | 二进制i | i >> 1 | 二进制(i >> 1) | i ^ (i >> 1) | 格雷码二进制 | 格雷码十进制 |
|---------|---------|--------|---------------|--------------|--------------|-------------|
| 0       | 00      | 0      | 00            | 00 ^ 00 = 00 | 00           | 0           |
| 1       | 01      | 0      | 00            | 01 ^ 00 = 01 | 01           | 1           |
| 2       | 10      | 1      | 01            | 10 ^ 01 = 11 | 11           | 3           |
| 3       | 11      | 1      | 01            | 11 ^ 01 = 10 | 10           | 2           |

## 算法原理深度解析

### 为什么 `i ^ (i >> 1)` 能生成格雷码？

#### 1. 相邻性证明
当i增加1时，其二进制表示会发生如下变化：
- 从右往左数，第一个0会变成1
- 该0右边的所有1会变成0

例如：i=2 (10) → i+1=3 (11)

此时：
- `i >> 1 = 1 (01)`
- `i+1 >> 1 = 1 (01)`
- 异或结果仅在变化的位上不同

#### 2. 二进制进位链与异或操作的深度解析

#### 关键点1：i增加1时的二进制进位链

当十进制数i增加1时，其二进制表示会发生**进位现象**，具体表现为：
1. 从右往左找到第一个为0的位
2. 将该位从0变为1
3. 将该位右侧的所有位从1变为0

**例子分析**：

| 十进制 | 二进制 | 加1后的十进制 | 加1后的二进制 | 进位链范围 |
|--------|--------|--------------|--------------|------------|
| 0      | 000    | 1            | 001          | 无进位     |
| 1      | 001    | 2            | 010          | 第0位      |
| 2      | 010    | 3            | 011          | 无进位     |
| 3      | 011    | 4            | 100          | 第0-1位    |
| 4      | 100    | 5            | 101          | 无进位     |
| 5      | 101    | 6            | 110          | 第0位      |
| 6      | 110    | 7            | 111          | 无进位     |
| 7      | 111    | 8            | 1000         | 第0-2位    |

**进位链的特点**：
- 进位链是连续的，从最右边的0位开始向左延伸
- 进位链的长度取决于i的二进制表示中末尾连续1的个数

#### 关键点2：异或操作抵消进位影响的原理

公式 `G(i) = i ^ (i >> 1)` 中的**右移+异或**操作，巧妙地抵消了进位的影响：

**步骤分解**：
1. `i >> 1`：将i的二进制表示向右移动一位，相当于「去掉最右边的一位」
2. `i ^ (i >> 1)`：将原数与右移后的数进行异或操作

**核心机制**：
- 对于没有进位的情况（i的最后一位是0），i+1只改变最后一位，异或后也只改变最后一位
- 对于有进位的情况（i的最后一位是1），i+1会产生进位链，而异或操作确保只有进位链的起始位发生变化

**详细案例分析**：

以i=3（二进制011）和i=4（二进制100）为例：

```
步骤1：i=3 (011)
- i >> 1 = 001
- G(3) = 011 ^ 001 = 010 (十进制2)

步骤2：i=4 (100)
- i >> 1 = 010
- G(4) = 100 ^ 010 = 110 (十进制6)

比较G(3)和G(4)：
- G(3) = 010
- G(4) = 110
- 只有第2位（从0开始计数）发生了变化
```

以i=2（二进制010）和i=3（二进制011）为例：

```
步骤1：i=2 (010)
- i >> 1 = 001
- G(2) = 010 ^ 001 = 011 (十进制3)

步骤2：i=3 (011)
- i >> 1 = 001
- G(3) = 011 ^ 001 = 010 (十进制2)

比较G(2)和G(3)：
- G(2) = 011
- G(3) = 010
- 只有第0位发生了变化
```

#### 异或操作的可视化理解

考虑n=3的情况，观察i和i>>1的二进制关系：

| i | 二进制i | 二进制(i>>1) | 二进制(i^(i>>1)) | G(i) |
|---|---------|-------------|-----------------|------|
| 0 | 000     | 000         | 000             | 0    |
| 1 | 001     | 000         | 001             | 1    |
| 2 | 010     | 001         | 011             | 3    |
| 3 | 011     | 001         | 010             | 2    |
| 4 | 100     | 010         | 110             | 6    |
| 5 | 101     | 010         | 111             | 7    |
| 6 | 110     | 011         | 101             | 5    |
| 7 | 111     | 011         | 100             | 4    |

**观察发现**：
- 任意相邻的G(i)和G(i+1)只有一位不同
- 异或操作恰好抵消了i增加1时产生的进位链影响
- 只保留了进位链的起始位变化

### 时间复杂度分析
- **总时间复杂度**：O(2^n)
  - 循环执行2^n次
  - 每次循环中的位运算和向量插入都是O(1)操作

### 空间复杂度分析
- **总空间复杂度**：O(2^n)
  - 存储2^n个格雷码
  - 不考虑输出空间的话，空间复杂度为O(1)

## 格雷码的性质验证

生成的序列满足格雷码的所有核心性质：

### 1. 相邻性
任意两个相邻的数字，其二进制表示恰好有一位不同：
- 0(00) ↔ 1(01)：仅第0位不同
- 1(01) ↔ 3(11)：仅第1位不同
- 3(11) ↔ 2(10)：仅第0位不同

### 2. 循环性
第一个数字和最后一个数字的二进制表示也恰好有一位不同：
- 0(00) ↔ 2(10)：仅第1位不同

### 3. 唯一性
序列中包含2^n个不同的整数：
- n=2时，序列为[0,1,3,2]，包含4个不同的整数

### 4. 起始性
序列以0开头：
- 当i=0时，0 ^ 0 = 0

## 扩展应用

### 1. 反射法生成格雷码
除了位运算公式外，还可以使用反射法生成格雷码：

```cpp
vector<int> grayCode(int n) {
    vector<int> res = {0};
    for (int i = 0; i < n; ++i) {
        int size = res.size();
        for (int j = size - 1; j >= 0; --j) {
            res.push_back(res[j] | (1 << i));
        }
    }
    return res;
}
```

### 2. 实际应用场景
- **数字通信**：减少信号传输错误
- **旋转编码器**：避免位置检测时的歧义
- **数字电路设计**：减少竞争冒险现象
- **纠错码**：用于数据传输的错误检测和纠正

## 总结

### 代码核心要点
1. **第39行循环**：通过 `1 << n` 生成2^n次迭代，覆盖所有n位二进制数
2. **第40行公式**：使用 `i ^ (i >> 1)` 位运算生成每个格雷码

### 算法优势
- **代码简洁**：仅需3行核心代码
- **时间高效**：O(2^n)时间复杂度，无额外开销
- **空间高效**：O(2^n)空间复杂度，仅存储结果
- **易于理解**：基于数学公式，逻辑清晰

格雷码的位运算生成方法是算法设计中巧妙运用位操作的经典案例，展示了数学公式在算法优化中的强大威力。# 89. 格雷编码

